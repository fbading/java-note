## 一、Java程序运行过程

<img src="https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210411162040.png" alt="image-20210411162038714" style="zoom:50%;" />

**JVM的跨平台**

**JVM的语言无关性**

## 二、常见的JVM

* Hotspot
* J9
* TaobaoVM
* zing

## 三、内存结构

<img src="https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210411170836.png" alt="image-20210411170834691" style="zoom:50%;" />

`也可以叫做运行时数据区`

主要分为线程私有区域、线程共有区域和直接内存

### 3.1 线程私有区

* 虚拟机栈：存储线程运行 java 方法所需的数据，指令、返回地址。【也就是数据结构，先进后出（FILO）】

  * 虚拟机栈的大小缺省为 1M，可用参数 –Xss 调整大小，默认：-Xss1024KB

  * 里面压入很多栈幁，每一个栈幁代表一个方法
  * 栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址)
    * 局部变量表：存储每个方法的局部变量的
    * 操作数栈：可以理解为高速缓存，也是一个先进后出的操作数栈
    * 动态连接：java语言的多态
    * 完成出口：正常返回（调用程序计数器中的地址作为返回）

   

* 本地方法栈：运行的本地方法

* 程序计数器：指向当前线程正在执行的字节码指令的地址。

  * 不会发生内存溢出

### 3.2 线程共享区

* 方法区：静态变量、常量、运行时常量池、类信息。

  * JVM的逻辑划分。Jdk1.7 永久代 。Jdk1.8 元空间。
  * class文件。解析。常量池【运行时常量池，静态常量池】。
    * 运行时常量池：class类加载的时候会将符号引号变成直接引用【就是内存地址】。

  例子：String a = "ding";

  

* 堆：对象

### 3.3 参数设置

>* 堆：-Xms30m -Xmx30m
>* 元空间：-XX:MaxMetaspaceSize=30m
>* CMS垃圾回收器: -XX:UseConcMarkSweepGC
>* -XX:+PrintGCDetails



### 3.4 JVM的内存区域

**总结一下 JVM 运行内存的整体流程**

>JVM 在操作系统上启动，申请内存，先进行运行时数据区的初始化，然后把类加载到方法区，最后执行方法。
>方法的执行和退出过程在内存上的体现上就是虚拟机栈中栈帧的入栈和出栈。
>同时在方法的执行过程中创建的对象一般情况下都是放在堆中，最后堆中的对象也是需要进行垃圾回收清理的。



**堆空间分代划分**

>堆被划分为新生代和老年代（Tenured），新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。



**GC概念**

>GC- Garbage Collection 垃圾回收，在 JVM 中是自动化的垃圾回收机制，我们一般不用去关注，在 JVM 中 GC 的重要区域是堆空间。
>我们也可以通过一些额外方式主动发起它，比如 System.gc(),主动发起



### 3.5 JHSDB 工具

JHSDB 是一款基于服务性代理实现的进程外调试工具。服务性代理是 HotSpot 虚拟机中一组用于映射 Java 虚拟机运行信息的，主要基于 Java 语言实现的
API 集合。

**使用步骤解析：**

>* 目录：C:\Program Files\Java\jdk1.8.0_201\lib 进入命令行，执行 java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB



## 四、JVM中对象及引用

### 4.1 JVM中对象的创建过程

检查加载---分配内存---内存空间初始化---设置---对象初始化

>* 检查加载：首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用 ：符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过
>* 分配内存：指针碰撞、空闲列表
>    * 并发安全：cas、分配缓冲【TLAB】
>* 内存空间初始化：对象参数的初始化【零值赋值】
>* 设置：设置对象头的信息（mark world 和 klass pointer）
>* 对象初始化：就是对象的构造方法

### 4.2 对象的内存布局

* 对象头
  * 存储对象自身的运行时数据（Mark word）
    * 哈希码
    * GC分带年龄
    * 锁状态标识
    * 线程持有的锁
    * 偏向线程ID
    * 偏向时间戳
  * 类型指针（klass pointer）
  * 若为对象数组，还应有记录数组长度的数据
* 实例数据
* 对齐填充（非必须）

### 4.3 对象访问定位

* 句柄：如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。【稳定性好】
* 直接指针： reference 中存储的直接就是对象地址【效率高】

### 4.4 判断对象存活

* 引用计数法：解决不了（循环引用）
* 可达性分析法:【GC Roots】
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  * 方法区中类静态属性引用的对象；java 类的引用类型静态变量。
  * 方法区中常量引用的对象；比如：字符串常量池里的引用。
  * 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。

### 4.5 对象分配策略

* 对象优先分配在Eden区
  * 也可能分配在栈上【逃逸分析】 
* 空间分配担保：防止的进行minorGC的时候老年代空间不够使用。
* 大对象直接进入老年代
* 长期存活的对象进入老年代：15次进入老年代
* 动态对象年龄判定：相同年龄大小大于单个50%可以直接接入老年代。

## 五、垃圾回收算法
* 复制算法：没有内存碎片，利用率只有一半
* 标记清除算法：位置不连续产生碎片，
* 标记整理算法：没有内存碎片，两边扫描指针需要调整

## 六、垃圾回收器

<img src="https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210412211133.png" alt="image-20210412211127628" style="zoom:50%;" />

<img src="https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210412211100.png" alt="image-20210412211058189" style="zoom:50%;" />

<img src="https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210412210558.png" alt="image-20210412210549172" style="zoom: 50%;" />

### 6.1 CMS

`Concurrent Mark Sweep 标记清除算法`

* 初始标记： 标记GC Roots对象关联的对象
* 并发标记：标记GC Roots下面的对象
* 重新标记：
* 并发清除

![image-20210413095640037](https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210413095641.png)

**CMS中的问题**

>* CPU敏感
>* 浮动垃圾
>* 内存碎片

### 6.2 G1[Garbage first]

`划分region区` （1~32M 2的次幂）

* Region区
* 筛选回收
* 可预测停顿
* 算法 -- 复制和标记整理 

![image-20210413131446756](https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210413131448.png)

![image-20210413105532760](https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210413105534.png)

## 七、并发标记

### 7.1 三色标记

`好处：异步执行`

* 黑色：根对象，或者该对象与它的子对象都被扫描过。

* 灰色：对本身被扫描，但是还没扫描完该对象的子对象。

* 白色：未被扫描对象，如果扫描完所有对象之后，最终为白色的为不可达对象，既垃圾对象

  

**GC并发出现漏标问题**

>* STAB:快照 【G1】=====引用的删除
>* incremental update 【CMS】 ===== 引用的增加【重新再扫一次】

## 八、安全点与安全区域

**安全点：**

>* 当GC进行回收的时候肯定不是强制业务线程立马停止的【主动式中断】，业务线程轮训标志【GC开始了】就找最近的安全点挂起。
>* 方法调用、循环跳转，异常跳转等，一般是这些指令产生安全点主动式中断。

**安全区域：**

`要是业务线程都不执行（业务线程处于 Sleep 或者是 Blocked 状态），那么程序就没办法进入安全点，对于这种情况，就必须引入安全区域。`

>* 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

## 九、类加载机制

### 9.1 类生命周期【7个阶段】

* 加载
  * 将类的全限定名转化成二进制字节流。
  * 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据区的访问入口。
* 验证
  * 文件格式验证【操作二进制流数据，在I/O上】
    * 是否已魔术CAFEBABE开头，主次版本是否在当前Java虚拟机接受范围之内。
  * 元数据验证【以下都是在内存-方法区上】
    * 验证一些方法和变量是否符合java语言规范
  * 字节码验证(方法)
  * 符号引用验证
* 准备
  * 静态变量赋值。
* 解析
  * 将JVM的符号引号直接替换成直接引用的过程。
* 初始化【初始化的类肯定就是被加载了，时序问题】
  * 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
    * java代码场景：new关键字实例化对象、读取或者设置一个类的静态字段（除final修饰外）、调用类的静态方法
  * 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 
  * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  * 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main（）方法的那个类），虚拟机会先初始化这个主类。
* 使用
* 卸载

`static静态代码块是线程安全的，只允许一个线程进行加载`

## 十、类加载器

* 启动类加载器：Bootstrap ClassLoader
* 拓展类加载器: Extention ClassLoader
* 应用程序加载器：Application Class



**双亲委派模型:**

`每次加载的时候都向上询问是否有加载过`

![image-20210418141312267](https://gitee.com/dingdingxiaolong/typora_img/raw/master/img/20210418141313.png)

**spi如何打破双亲委派的：**

>* 应该是属于 BootStrap 类加载器加载的，但是还是在 app 类加载器去加载的它
>* 利用线程来加载自己AppClassLoader加载器的





















